***************************************************************************

IPython post-mortem report

{'commit_hash': u'8ff8693',
 'commit_source': 'installation',
 'default_encoding': 'UTF-8',
 'ipython_path': '/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython',
 'ipython_version': '4.0.3',
 'os_name': 'posix',
 'platform': 'Darwin-15.4.0-x86_64-i386-64bit',
 'sys_executable': '/Users/cpd/miniconda2/envs/cpd/bin/python',
 'sys_platform': 'darwin',
 'sys_version': '2.7.11 |Anaconda 2.5.0 (x86_64)| (default, Dec  6 2015, 18:57:58) \n[GCC 4.2.1 (Apple Inc. build 5577)]'}

***************************************************************************



***************************************************************************

Crash traceback:

---------------------------------------------------------------------------
---------------------------------------------------------------------------
KeyboardInterrupt  Python 2.7.11: /Users/cpd/miniconda2/envs/cpd/bin/python
                                                   Tue Apr 19 01:46:33 2016
A problem occurred executing Python code.  Here is the sequence of function
calls leading up to the error, with the most recent (innermost) call last.
/Users/cpd/miniconda2/envs/cpd/bin/ipython in <module>()
      1 #!/bin/bash /Users/cpd/miniconda2/envs/cpd/bin/python.app
      2 if __name__ == '__main__':
      3     import sys
      4     from IPython import start_ipython
      5 
----> 6     sys.exit(start_ipython())
        global sys.exit = <built-in function exit>
        global start_ipython = <function start_ipython at 0x104281848>

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/__init__.pyc in start_ipython(argv=None, **kwargs={})
    104     This is a public API method, and will survive implementation changes.
    105     
    106     Parameters
    107     ----------
    108     
    109     argv : list or None, optional
    110         If unspecified or None, IPython will parse command-line options from sys.argv.
    111         To prevent any command-line parsing, pass an empty list: `argv=[]`.
    112     user_ns : dict, optional
    113         specify this dictionary to initialize the IPython user namespace with particular values.
    114     kwargs : various, optional
    115         Any other kwargs will be passed to the Application constructor,
    116         such as `config`.
    117     """
    118     from IPython.terminal.ipapp import launch_new_instance
--> 119     return launch_new_instance(argv=argv, **kwargs)
        launch_new_instance = <bound method MetaHasTraits.launch_instance of <class 'IPython.terminal.ipapp.TerminalIPythonApp'>>
        argv = None
        kwargs = {}
    120 
    121 def start_kernel(argv=None, **kwargs):
    122     """Launch a normal IPython kernel instance (as opposed to embedded)
    123     
    124     `IPython.embed_kernel()` puts a shell in a particular calling scope,
    125     such as a function or method for debugging purposes,
    126     which is often not desirable.
    127     
    128     `start_kernel()` does full, regular IPython initialization,
    129     including loading startup files, configuration, etc.
    130     much of which is skipped by `embed()`.
    131     
    132     Parameters
    133     ----------
    134     

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/traitlets/config/application.pyc in launch_instance(cls=<class 'IPython.terminal.ipapp.TerminalIPythonApp'>, argv=None, **kwargs={})
    573             lines.append(cls.class_config_section())
    574         return '\n'.join(lines)
    575 
    576     def exit(self, exit_status=0):
    577         self.log.debug("Exiting application: %s" % self.name)
    578         logging.shutdown()
    579         sys.exit(exit_status)
    580 
    581     @classmethod
    582     def launch_instance(cls, argv=None, **kwargs):
    583         """Launch a global instance of this Application
    584         
    585         If a global instance already exists, this reinitializes and starts it
    586         """
    587         app = cls.instance(**kwargs)
--> 588         app.initialize(argv)
        app.initialize = <bound method TerminalIPythonApp.initialize of <IPython.terminal.ipapp.TerminalIPythonApp object at 0x1020e5650>>
        argv = None
    589         app.start()
    590 
    591 #-----------------------------------------------------------------------------
    592 # utility functions, for convenience
    593 #-----------------------------------------------------------------------------
    594 
    595 def boolean_flag(name, configurable, set_help='', unset_help=''):
    596     """Helper for building basic --trait, --no-trait flags.
    597 
    598     Parameters
    599     ----------
    600 
    601     name : str
    602         The name of the flag.
    603     configurable : str

<decorator-gen-111> in initialize(self=<IPython.terminal.ipapp.TerminalIPythonApp object>, argv=None)

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/traitlets/config/application.pyc in catch_config_error(method=<function initialize>, app=<IPython.terminal.ipapp.TerminalIPythonApp object>, *args=(None,), **kwargs={})
     59 
     60 #-----------------------------------------------------------------------------
     61 # Application class
     62 #-----------------------------------------------------------------------------
     63 
     64 @decorator
     65 def catch_config_error(method, app, *args, **kwargs):
     66     """Method decorator for catching invalid config (Trait/ArgumentErrors) during init.
     67 
     68     On a TraitError (generally caused by bad config), this will print the trait's
     69     message, and exit the app.
     70     
     71     For use on init methods, to prevent invoking excepthook on invalid input.
     72     """
     73     try:
---> 74         return method(app, *args, **kwargs)
        method = <function initialize at 0x104281050>
        app = <IPython.terminal.ipapp.TerminalIPythonApp object at 0x1020e5650>
        args = (None,)
        kwargs = {}
     75     except (TraitError, ArgumentError) as e:
     76         app.print_help()
     77         app.log.fatal("Bad config encountered during initialization:")
     78         app.log.fatal(str(e))
     79         app.log.debug("Config at the time: %s", app.config)
     80         app.exit(1)
     81 
     82 
     83 class ApplicationError(Exception):
     84     pass
     85 
     86 
     87 class LevelFormatter(logging.Formatter):
     88     """Formatter with additional `highlevel` record
     89     

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/terminal/ipapp.pyc in initialize(self=<IPython.terminal.ipapp.TerminalIPythonApp object>, argv=None)
    303     def initialize(self, argv=None):
    304         """Do actions after construct, but before starting the app."""
    305         super(TerminalIPythonApp, self).initialize(argv)
    306         if self.subapp is not None:
    307             # don't bother initializing further, starting subapp
    308             return
    309         # print self.extra_args
    310         if self.extra_args and not self.something_to_run:
    311             self.file_to_run = self.extra_args[0]
    312         self.init_path()
    313         # create the shell
    314         self.init_shell()
    315         # and draw the banner
    316         self.init_banner()
    317         # Now a variety of things that happen after the banner is printed.
--> 318         self.init_gui_pylab()
        self.init_gui_pylab = <bound method TerminalIPythonApp.init_gui_pylab of <IPython.terminal.ipapp.TerminalIPythonApp object at 0x1020e5650>>
    319         self.init_extensions()
    320         self.init_code()
    321 
    322     def init_shell(self):
    323         """initialize the InteractiveShell instance"""
    324         # Create an InteractiveShell instance.
    325         # shell.display_banner should always be False for the terminal
    326         # based app, because we call shell.show_banner() by hand below
    327         # so the banner shows *before* all extension loading stuff.
    328         self.shell = TerminalInteractiveShell.instance(parent=self,
    329                         display_banner=False, profile_dir=self.profile_dir,
    330                         ipython_dir=self.ipython_dir, user_ns=self.user_ns)
    331         self.shell.configurables.append(self)
    332 
    333     def init_banner(self):

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/core/shellapp.pyc in init_gui_pylab(self=<IPython.terminal.ipapp.TerminalIPythonApp object>)
    217         shell = self.shell
    218         if self.pylab:
    219             enable = lambda key: shell.enable_pylab(key, import_all=self.pylab_import_all)
    220             key = self.pylab
    221         elif self.matplotlib:
    222             enable = shell.enable_matplotlib
    223             key = self.matplotlib
    224         elif self.gui:
    225             enable = shell.enable_gui
    226             key = self.gui
    227         
    228         if not enable:
    229             return
    230         
    231         try:
--> 232             r = enable(key)
        r = undefined
        enable = <function enable_gui at 0x104092ed8>
        key = u'qt'
    233         except ImportError:
    234             self.log.warn("Eventloop or matplotlib integration failed. Is matplotlib installed?")
    235             self.shell.showtraceback()
    236             return
    237         except Exception:
    238             self.log.warn("GUI event loop or pylab initialization failed")
    239             self.shell.showtraceback()
    240             return
    241             
    242         if isinstance(r, tuple):
    243             gui, backend = r[:2]
    244             self.log.info("Enabling GUI event loop integration, "
    245                       "eventloop=%s, matplotlib=%s", gui, backend)
    246             if key == "auto":
    247                 print("Using matplotlib backend: %s" % backend)

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/terminal/interactiveshell.pyc in enable_gui(gui=u'qt', app=None)
    292     )
    293     usage = Unicode(interactive_usage)
    294     
    295     # This `using_paste_magics` is used to detect whether the code is being
    296     # executed via paste magics functions
    297     using_paste_magics = CBool(False)
    298 
    299     # In the terminal, GUI control is done via PyOS_InputHook
    300     @staticmethod
    301     def enable_gui(gui=None, app=None):
    302         """Switch amongst GUI input hooks by name.
    303         """
    304         # Deferred import
    305         from IPython.lib.inputhook import enable_gui as real_enable_gui
    306         try:
--> 307             return real_enable_gui(gui, app)
        real_enable_gui = <bound method InputHookManager.enable_gui of <IPython.lib.inputhook.InputHookManager object at 0x104233e90>>
        gui = u'qt'
        app = None
    308         except ValueError as e:
    309             raise UsageError("%s" % e)
    310     
    311     system = InteractiveShell.system_raw
    312 
    313     #-------------------------------------------------------------------------
    314     # Overrides of init stages
    315     #-------------------------------------------------------------------------
    316 
    317     def init_display_formatter(self):
    318         super(TerminalInteractiveShell, self).init_display_formatter()
    319         # terminal only supports plaintext
    320         self.display_formatter.active_types = ['text/plain']
    321 
    322     #-------------------------------------------------------------------------

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/lib/inputhook.pyc in enable_gui(self=<IPython.lib.inputhook.InputHookManager object>, gui=u'qt', app=None)
    235         one.
    236         """
    237         if gui in (None, GUI_NONE):
    238             return self.disable_gui()
    239         
    240         if gui in self.aliases:
    241             return self.enable_gui(self.aliases[gui], app)
    242         
    243         try:
    244             gui_hook = self.guihooks[gui]
    245         except KeyError:
    246             e = "Invalid GUI request {!r}, valid ones are: {}"
    247             raise ValueError(e.format(gui, ', '.join(self.guihooks)))
    248         self._current_gui = gui
    249 
--> 250         app = gui_hook.enable(app)
        app = None
        gui_hook.enable = <bound method Qt4InputHook.enable of <IPython.lib.inputhook.Qt4InputHook object at 0x104248050>>
    251         if app is not None:
    252             app._in_event_loop = True
    253             self.apps[gui] = app        
    254         return app
    255 
    256     def disable_gui(self):
    257         """Disable GUI event loop integration.
    258         
    259         If an application was registered, this sets its ``_in_event_loop``
    260         attribute to False. It then calls :meth:`clear_inputhook`.
    261         """
    262         gui = self._current_gui
    263         if gui in self.apps:
    264             self.apps[gui]._in_event_loop = False
    265         return self.clear_inputhook()

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/lib/inputhook.pyc in enable(self=<IPython.lib.inputhook.Qt4InputHook object>, app=None)
    352 
    353         Notes
    354         -----
    355         This methods sets the PyOS_InputHook for PyQt4, which allows
    356         the PyQt4 to integrate with terminal based applications like
    357         IPython.
    358 
    359         If ``app`` is not given we probe for an existing one, and return it if
    360         found.  If no existing app is found, we create an :class:`QApplication`
    361         as follows::
    362 
    363             from PyQt4 import QtCore
    364             app = QtGui.QApplication(sys.argv)
    365         """
    366         from IPython.lib.inputhookqt4 import create_inputhook_qt4
--> 367         app, inputhook_qt4 = create_inputhook_qt4(self.manager, app)
        app = None
        inputhook_qt4 = undefined
        create_inputhook_qt4 = <function create_inputhook_qt4 at 0x1047348c0>
        self.manager = <IPython.lib.inputhook.InputHookManager object at 0x104233e90>
    368         self.manager.set_inputhook(inputhook_qt4)
    369         if _use_appnope():
    370             from appnope import nope
    371             nope()
    372 
    373         return app
    374 
    375     def disable_qt4(self):
    376         """Disable event loop integration with PyQt4.
    377 
    378         This restores appnapp on OS X
    379         """
    380         if _use_appnope():
    381             from appnope import nap
    382             nap()

/Users/cpd/miniconda2/envs/cpd/lib/python2.7/site-packages/IPython/lib/inputhookqt4.pyc in create_inputhook_qt4(mgr=<IPython.lib.inputhook.InputHookManager object>, app=None)
     53 
     54     Notes
     55     -----
     56     We use a custom input hook instead of PyQt4's default one, as it
     57     interacts better with the readline packages (issue #481).
     58 
     59     The inputhook function works in tandem with a 'pre_prompt_hook'
     60     which automatically restores the hook as an inputhook in case the
     61     latter has been temporarily disabled after having intercepted a
     62     KeyboardInterrupt.
     63     """
     64 
     65     if app is None:
     66         app = QtCore.QCoreApplication.instance()
     67         if app is None:
---> 68             app = QtGui.QApplication([" "])
        app = None
        global QtGui.QApplication = <class 'PyQt4.QtGui.QApplication'>
     69 
     70     # Re-use previously created inputhook if any
     71     ip = InteractiveShell.instance()
     72     if hasattr(ip, '_inputhook_qt4'):
     73         return app, ip._inputhook_qt4
     74 
     75     # Otherwise create the inputhook_qt4/preprompthook_qt4 pair of
     76     # hooks (they both share the got_kbdint flag)
     77 
     78     def inputhook_qt4():
     79         """PyOS_InputHook python hook for Qt4.
     80 
     81         Process pending Qt events and if there's no pending keyboard
     82         input, spend a short slice of time (50ms) running the Qt event
     83         loop.

KeyboardInterrupt: 

***************************************************************************

History of session input:
*** Last line of input (may not be in above history):
